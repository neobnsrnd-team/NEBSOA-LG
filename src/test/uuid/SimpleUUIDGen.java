/*
 * Spider Framework
 * 
 * Copyright (c) 2006-2007 ServerSide Corp. All Rights Reserved.
 * 
 * 본 소스 및 바이너리 파일에 대한 권한은 모두 ServerSide 에 있습니다.
 * 저작자와의 협의 없이 수정 및 무단 배포를 금합니다.
 */

package test.uuid;

import java.math.BigInteger;
import java.security.SecureRandom;
import java.util.Random;

import nebsoa.common.util.FormatUtil;

/*******************************************************************
 * <pre>
 * 1.설명 
 * Apache-AXIS 에서 사용하는 UUID generator 를 가져옴.
 * 아래는 Apache-AXIS 에 설명되어 있는 내용이다.
 * 
 * Used to create new universally unique identifiers or UUID's (sometimes called GUID's).
 * UDDI UUID's are allways formmated according to DCE UUID conventions.
 * 
 * 2.사용법
 * 
 * <font color="red">
 * 3.주의사항
 * </font>
 *
 * @author $Author: cvs $
 * @version
 *******************************************************************
 * - 변경이력 (버전/변경일시/작성자)
 * 
 * $Log: SimpleUUIDGen.java,v $
 * Revision 1.1  2018/01/15 03:39:50  cvs
 * *** empty log message ***
 *
 * Revision 1.1  2016/04/15 02:22:44  cvs
 * neo cvs init
 *
 * Revision 1.1  2011/07/01 02:13:51  yshong
 * *** empty log message ***
 *
 * Revision 1.1  2008/11/18 11:27:24  김성균
 * *** empty log message ***
 *
 * Revision 1.1  2008/11/18 11:01:27  김성균
 * LGT Gateway를 위한 프로젝트로 분리
 *
 * Revision 1.1  2008/08/04 08:54:55  youngseokkim
 * *** empty log message ***
 *
 * Revision 1.2  2008/02/20 00:42:48  오재훈
 * *** empty log message ***
 *
 * Revision 1.1  2007/11/26 08:38:55  안경아
 * *** empty log message ***
 *
 * Revision 1.1  2006/11/21 05:50:22  이종원
 * *** empty log message ***
 *
 * Revision 1.2  2006/06/17 10:37:45  김성균
 * *** empty log message ***
 *
 * </pre>
 ******************************************************************/
public class SimpleUUIDGen implements UUIDGen {
	
    private static final BigInteger countStart = new BigInteger("-12219292800000");  // 15 October 1582
    private static final int clock_sequence = (new Random()).nextInt(16384);
    private static final byte ZERO = (byte) 48; // "0"
    private static final byte ONE  = (byte) 49; // "1"
    private static Random secureRandom = null;

    static {
        // problem: the node should be the IEEE 802 ethernet address, but can not
        // be retrieved in Java yet.
        // see bug ID 4173528
        // workaround (also suggested in bug ID 4173528)
        // If a system wants to generate UUIDs but has no IEE 802 compliant
        // network card or other source of IEEE 802 addresses, then this section
        // describes how to generate one.
        // The ideal solution is to obtain a 47 bit cryptographic quality random
        // number, and use it as the low 47 bits of the node ID, with the most
        // significant bit of the first octet of the node ID set to 1. This bit
        // is the unicast/multicast bit, which will never be set in IEEE 802
        // addresses obtained from network cards; hence, there can never be a
        // conflict between UUIDs generated by machines with and without network
        // cards.
        try {
            secureRandom = SecureRandom.getInstance("SHA1PRNG", "SUN");
        } catch (Exception e) {
            secureRandom = new Random();
        }//end try catch
    }//end static

	/**
	 * <pre>
	 * UUID 를 리턴합니다.
	 * 
     * Creates a new UUID. The algorithm used is described by The Open Group.
     * See <a href="http://www.opengroup.org/onlinepubs/009629399/apdxa.htm">
     * Universal Unique Identifier</a> for more details.
     * <p>
     * Due to a lack of functionality in Java, a part of the UUID is a secure
     * random. This results in a long processing time when this method is called
     * for the first time.
	 * </pre>
	 * 
	 * @return 생성된 uuid
	 * @see test.uuid.UUIDGen#nextUUID()
	 */
	public String nextUUID() {
        // TODO: this method has to be checked for it's correctness. I'm not sure the standard is
        // implemented correctly.

        // the count of 100-nanosecond intervals since 00:00:00.00 15 October 1582
        BigInteger count;

        // the number of milliseconds since 1 January 1970
        BigInteger current = BigInteger.valueOf(System.currentTimeMillis());

        // the number of milliseconds since 15 October 1582
        BigInteger countMillis = current.subtract(countStart);

        // the result
        count = countMillis.multiply(BigInteger.valueOf(10000));
        byte[] bits = FormatUtil.lPadding(count.toString(2), 60, '0').getBytes();

        // the time_low field
        byte[] time_low = new byte[32];
        for (int i = 0; i < 32; i++)
            time_low[i] = bits[bits.length - i - 1];

        // the time_mid field
        byte[] time_mid = new byte[16];
        for (int i = 0; i < 16; i++)
            time_mid[i] = bits[bits.length - 32 - i - 1];

        // the time_hi_and_version field
        byte[] time_hi_and_version = new byte[16];
        for (int i = 0; i < 12; i++)
            time_hi_and_version[i] = bits[bits.length - 48 - i - 1];

        time_hi_and_version[12] = ONE;
        time_hi_and_version[13] = ZERO;
        time_hi_and_version[14] = ZERO;
        time_hi_and_version[15] = ZERO;

        // the clock_seq_low field
        BigInteger clockSequence = BigInteger.valueOf(clock_sequence);
        byte[] clock_bits = FormatUtil.lPadding(clockSequence.toString(2), 14, '0').getBytes();
        byte[] clock_seq_low = new byte[8];
        for (int i = 0; i < 8; i++) {
            clock_seq_low[i] = clock_bits[clock_bits.length - i - 1];
        }//end for

        // the clock_seq_hi_and_reserved
        byte[] clock_seq_hi_and_reserved = new byte[8];
        for (int i = 0; i < 6; i++)
            clock_seq_hi_and_reserved[i] = clock_bits[clock_bits.length - 8 - i - 1];

        clock_seq_hi_and_reserved[6] = ZERO;
        clock_seq_hi_and_reserved[7] = ONE;

        String timeLow = Long.toHexString((new BigInteger(new String(reverseArray(time_low)), 2)).longValue());
        timeLow = FormatUtil.lPadding(timeLow, 8, '0');

        String timeMid = Long.toHexString((new BigInteger(new String(reverseArray(time_mid)), 2)).longValue());
        timeMid = FormatUtil.lPadding(timeMid, 4, '0');

        String timeHiAndVersion = Long.toHexString((new BigInteger(new String(reverseArray(time_hi_and_version)), 2)).longValue());
        timeHiAndVersion = FormatUtil.lPadding(timeHiAndVersion, 4, '0');

        String clockSeqHiAndReserved = Long.toHexString((new BigInteger(new String(reverseArray(clock_seq_hi_and_reserved)), 2)).longValue());
        clockSeqHiAndReserved = FormatUtil.lPadding(clockSeqHiAndReserved, 2, '0');

        String clockSeqLow = Long.toHexString((new BigInteger(new String(reverseArray(clock_seq_low)), 2)).longValue());
        clockSeqLow = FormatUtil.lPadding(clockSeqLow, 2, '0');

        long nodeValue = secureRandom.nextLong();
        nodeValue = Math.abs(nodeValue);
        while (nodeValue > 140737488355328L) {
            nodeValue = secureRandom.nextLong();
            nodeValue = Math.abs(nodeValue);
        }//end while

        BigInteger nodeInt = BigInteger.valueOf(nodeValue);

        byte[] node_bits = FormatUtil.lPadding(nodeInt.toString(2), 47, '0').getBytes();
        byte[] node = new byte[48];
        for (int i = 0; i < 47; i++)
            node[i] = node_bits[node_bits.length - i - 1];

        node[47] = ONE;
        String theNode = Long.toHexString((new BigInteger(new String(reverseArray(node)), 2)).longValue());
        theNode = FormatUtil.lPadding(theNode, 12, '0');

        StringBuffer result = new StringBuffer(timeLow);
        result.append("-");
        result.append(timeMid);
        result.append("-");
        result.append(timeHiAndVersion);
        result.append("-");
        result.append(clockSeqHiAndReserved);
        result.append(clockSeqLow);
        result.append("-");
        result.append(theNode);
        return result.toString().toUpperCase();
	}//end of nextUUID()
	
    private static byte [] reverseArray(byte [] bits) {
        byte[] result = new byte[bits.length];
        for (int i = 0; i < result.length; i++) {
            result[i] = bits[result.length - 1 - i];
        }//end for
        return result;
    }//end of reverseArray()
    
    
    
	/*----------------------------------
	 * 
	 * 테스트 코드가 포함된 main() 메소드
	 * 
	 ----------------------------------*/
    
    public static void main(String [] args) {
    	for (int i = 0; i < 100; i++) {
    		String uuid = new SimpleUUIDGen().nextUUID();
    		System.out.println(uuid + "\t:\tlength=" + uuid.length());
    	}//end for
    }//end of main()

}// end of SimpleUUIDGen.java